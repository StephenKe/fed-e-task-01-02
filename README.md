# 一
> a\[6]() = 9
> 
> 跟作用域链有关。在循环体内部只定义了函数而不是执行，等待函数真正执行的时候，函数体内部的 i 变量将会往上一级作用域查找具体的值，它的上一级作用域就是循环体定义的 i，此时 i 已经循环到最后一次了，也就是 i = 9，因此函数执行的结果就是 9

# 二
> 报错: 不能在 temp 初始化前访问temp
> 
> if (true) 内部形成了块级作用域，temp 只会在 if 内部查找值，而 temp 是在下一行用 let 定义的，因此 temp 找不到值，会报错

# 三
> arr.sort()[0]

# 四
> var 定义变量，没有块的概念，可以跨块访问，不能跨函数访问，不初始化出现undefined，不会报错
> 
> let定义变量，只能在块作用域里访问，也不能跨函数访问，对函数外部无影响 
> 
> const定义常量，只能在块作用域里访问，也不能跨函数访问，使用时必须初始化(即必须赋值)，而且不能修改

# 五
> 20
> 
> setTimeout 使用了箭头函数，不会改变 this 指向，因此当前 this 指向还是 obj，this.a 可以访问到 obj.a，即是 20

# 六
> Symbol() 会生成一个独一无二(unique)的值，一般用于对象，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突

# 七
> 浅拷贝: B 拷贝 A，修改了 A 的值，B也随之改变[只拷贝了地址]。实现浅拷贝一般直接用 '=' 赋值或者 clone 只 clone 一层
> 
> 深拷贝: B 拷贝 A，修改了 A 的值，B不会改变[开辟一个新的内存空间用于存放拷贝的值]。实现深拷贝一般使用 clone 递归 clone 所有层级

# 八
> Typescript 是 Javascript 的超集。从语法层面上补全了 Javascript 作为解释性弱类型语言的缺点，为 Javascript 提供了一整套强类型检查系统[开发环境]，编译为生产环境代码后仍然是普通的 Javascript 代码

# 九
> 优点: 从语法层面上补全了 Javascript 作为解释性弱类型语言的缺点，为构建大型复杂应用提供了更安全可靠的保障
> 
> 缺点: 对小型项目不友好，开发成本高

# 十
> 优点: 立即回收垃圾对象，减少程序卡顿时间
> 
> 缺点: 不能回收循环引用对象[函数内部定义的互相引用对象]，资源消耗较大[需要对引用对象计数，遇到引用对象引用数量较大时资源消耗大]

# 十一
1. 标记活动对象
2. 整理标记地址使之连续
3. 非标记对象空间释放[垃圾回收]

# 十二
1. 从 From[活动对象存储空间] 标记整理后将活动对象拷贝到 To[空闲空间]
2. From 和 To 空间交换[地址交换]，至此 From 空间释放[垃圾回收]，To 存放新生代活动对象

# 十三
> 何时使用: 老生代存储区进行垃圾回收[GC]
> 
> 工作原理: 在进行标记的时候采用分段标记，不会阻塞 Javascript 执行线程，提高回收效率